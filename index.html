<!DOCTYPE html>
<html lang="en">
	<head>
		<title>GUTCP Orbitsphere WebGL Demo</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				text-align:center;
				cursor: pointer;
			}

			a {
				color:#0078ff;
			}

			#info {
				color: #ffffff;
				position: absolute;
				top: 10px;
				width: 100%;
			}

			#warning {
				color: #ff0000;
			}

		</style>
	</head>
	<body>

        <div id="info">
            <a href="http://www.brilliantlightpower.com/book/" target="_blank" rel="noopener">GUTCP Ch 1.5 - Generation of the Orbitsphere-CVFS</a>
            <br>Physics by : <a href="mailto:rmills@brilliantlightpower.com">Dr Randell L Mills</a> - Simulation by : <a href="mailto:vacamiguel@gmail.com">J Miguel Vaca</a> 
            <br> Select points-per-great circle: <span id="options"></span><br/>
        </div>

		<script src="https://threejs.org/build/three.js"></script>
		<script src="https://threejs.org/examples/js/Detector.js"></script>
		<script src="https://threejs.org/examples/js/libs/stats.min.js"></script>
		<script src="https://threejs.org/examples/js/libs/dat.gui.min.js"></script>
		<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
		<script src="https://threejs.org/examples/js/GPUComputationRenderer.js"></script>

        <!-- VERTICES vertex shader - Use this to update the position due to camera projection -->
		<script id="becvfVertexShader" type="x-shader/x-vertex">

			// For PI declaration:
			#include <common>

			uniform float cameraConstant;
			uniform float wavesPerRing;
            uniform float waveSpeed;
			uniform float uTime;
			uniform bool  animateBECVF;
			uniform float redBECVF;
			uniform float greenBECVF;
			uniform float blueBECVF;
            uniform float alphaBECVF;

			varying vec4 vColor;

			void main() {
			
				if(animateBECVF) {
                    float bright = mod(waveSpeed*uTime+uv.x, 1.0/wavesPerRing) * wavesPerRing;
                    vColor = vec4( (1.0-bright)*redBECVF, (1.0-bright)*greenBECVF, (1.0-bright)*blueBECVF, alphaBECVF );
				} else {
					vColor = vec4( redBECVF, greenBECVF, blueBECVF, alphaBECVF );
				}

				vec4 mvPosition = modelViewMatrix * vec4( position.xyz, 1.0 );
				
				gl_PointSize = 3.0;
				gl_Position = projectionMatrix * mvPosition;
			}

		</script>

        <!-- VERTICES vertex shader - Use this to update the position due to camera projection -->
		<script id="ocvfVertexShader" type="x-shader/x-vertex">

			// For PI declaration:
			#include <common>

			uniform float cameraConstant;
			uniform float wavesPerRing;
            uniform float waveSpeed;
			uniform float uTime;
			uniform bool  animateOCVF;
			uniform float redOCVF;
			uniform float greenOCVF;
			uniform float blueOCVF;
            uniform float alphaOCVF;

			varying vec4 vColor;

			void main() {
			
				if(animateOCVF) {
                    float bright = mod(waveSpeed*uTime+uv.x, 1.0/wavesPerRing) * wavesPerRing;
					vColor = vec4( (1.0-bright)*redOCVF, (1.0-bright)*greenOCVF, (1.0-bright)*blueOCVF, alphaOCVF );
				} else {
					vColor = vec4( redOCVF, greenOCVF, blueOCVF, alphaOCVF );
				}

				vec4 mvPosition = modelViewMatrix * vec4( position.xyz, 1.0 );
				
				gl_PointSize = 3.0;
				gl_Position = projectionMatrix * mvPosition;
			}
		</script>

        <!-- Grid vertex shader - Use this to update the position due to camera projection -->
        <script id="yVertexShader" type="x-shader/x-vertex">

            // For PI declaration:
            #include <common>

            uniform float cameraConstant;
            uniform float wavesPerRing;
            uniform float waveSpeed;
            uniform float uTime;
            uniform bool  animateY;
            uniform float redY;
            uniform float greenY;
            uniform float blueY;
            uniform float alphaY;

            varying vec4 vColor;

            void main() {

                if(animateY) {
                    float bright = mod(waveSpeed*uTime+uv.y, 1.0/wavesPerRing) * wavesPerRing;
                    vColor = vec4( (1.0-bright)*redY, (1.0-bright)*greenY, (1.0-bright)*blueY, alphaY );
                } else {
                    vColor = vec4( redY, greenY, blueY, alphaY );
                }
                vec4 mvPosition = modelViewMatrix * vec4( position.xyz, 1.0 );
                gl_PointSize = 2.0;
                gl_Position = projectionMatrix * mvPosition;
            }
        </script>

        <!-- Grid vertex shader - Use this to update the position due to camera projection -->
        <script id="gridVertexShader" type="x-shader/x-vertex">

            // For PI declaration:
            #include <common>

            uniform float cameraConstant;
            uniform float brightGrid;
            uniform float alphaGrid;

            varying vec4 vColor;

            void main() {

                vColor = vec4( brightGrid, brightGrid, brightGrid, alphaGrid );

                vec4 mvPosition = modelViewMatrix * vec4( position.xyz, 1.0 );

                gl_PointSize = 2.0;
                gl_Position = projectionMatrix * mvPosition;
            }
        </script>

		<!-- VERTICES fragment shader -->
		<script id="particleFragmentShader" type="x-shader/x-fragment">

			varying vec4 vColor;

			void main() {
				gl_FragColor = vColor;
			}

		</script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var isIE = /Trident/i.test( navigator.userAgent );
			var isEdge = /Edge/i.test( navigator.userAgent );

			var hash = document.location.hash.substr( 1 );
            var WIDTH = 0;

            // Set 'WIDTH' to option hash if set, else set it to 60 (vertices per ring) and (rings per rotation)
            if ( hash ) {
                hash = parseInt( hash, 0 );
                WIDTH = hash;
            } else {
                WIDTH = 60;
            }

			var container, stats;
			var camera, scene, renderer, geometry, controls;
			var clock = new THREE.Clock();
			var tick = 0;
			
			var VERTICES = WIDTH * WIDTH;
			
			function change( n ) {
				location.hash = n;
				location.reload();
				return false;
			}

            var options = '';
            for ( var i = 1; i <= 6; i++ ) {
                var j = i * 60;
                options += '<a href="#" onclick="return change(' + j + ')">' + j + '</a> ';
            }

            document.getElementById( 'options' ).innerHTML = options;

			if ( isEdge || isIE ) {
				document.getElementById( 'warning' ).innerText = 'particle counts greater than 16 may not render with ' + ( isEdge ? 'Edge' : 'IE11' );
			}

            var becvfPoints;
            var becvfLines;
			var becvfUniforms;

            var ocvfPoints;
            var ocvfLines;
			var ocvfUniforms;

            var yPoints_1_103;
            var yPoints_1_109;

            var gridUniforms;

            var effectController;

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 5, 15000 );
				camera.position.y = 120;
				camera.position.z = 400;

				scene = new THREE.Scene();

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				controls = new THREE.OrbitControls( camera, renderer.domElement );

				effectController = {
					// Can be changed dynamically
                    radius: 100.0,
                    waveSpeed: 0.50,
					wavesPerRing: 2.0,

                    brightGrid: 0.4,
                    alphaGrid:  1.0,

                    becvfGeometry: 'lines',
					showBECVF: true,
					animateBECVF: true,
					redBECVF:   1.0,
					greenBECVF: 0.0,
					blueBECVF:  0.0,
                    alphaBECVF: 1.0,

                    ocvfGeometry: 'lines',
					showOCVF: true,
					animateOCVF: true,
					redOCVF:   0.0,
					greenOCVF: 0.0,
					blueOCVF:  1.0,
                    alphaOCVF: 1.0,

                    showY: true,
                    animateY: true,
                    redY:   0.0,
                    greenY: 1.0,
                    blueY:  0.0,
                    alphaY: 1.0,

                    showYortho:  true,
                    animateYortho: true,
                    redYortho:   1.0,
                    greenYortho: 0.0,
                    blueYortho:  1.0,
                    alphaYortho: 1.0
				};

				//initComputeRenderer();

				stats = new Stats();
				container.appendChild( stats.dom );

				window.addEventListener( 'resize', onWindowResize, false );

                initGrid();
				initBECVF();
				initOCVF();
                initY_1_103();
                initY_1_109();

                initGUI();

				dynamicValuesChanger();
			}
			
            // Geometry based on GUTCP Equation 1.84:
			function initBECVF() {

				geometry = new THREE.BufferGeometry();

				// Storage for all the locations for the BECVF:
				var positions = new Float32Array( VERTICES * 3 );
				var uvs = new Float32Array( VERTICES * 2 );
				var p = 0;
				var theta = 0.0;
				var psi = 0.0;


				// Populate the BECVF positions:
				for ( var i = 0; i < WIDTH; i++ ) {
				
					theta = 2.0 * Math.PI * i / WIDTH;
					// Setup the 3x3 rotation matrix from GUTCP Eq(1.84)
					var becvfRot = new Float32Array(9);
					becvfRot[0+0] = ( 0.5 + 0.5*Math.cos(theta));
					becvfRot[0+1] = (-0.5 + 0.5*Math.cos(theta));
					becvfRot[0+2] = (-0.70711*Math.sin(theta));
					becvfRot[3+0] = (-0.5 + 0.5*Math.cos(theta));
					becvfRot[3+1] = ( 0.5 + 0.5*Math.cos(theta)); 
					becvfRot[3+2] = (-0.70711*Math.sin(theta));
					becvfRot[6+0] = ( 0.70711*Math.sin(theta));
					becvfRot[6+1] = ( 0.70711*Math.sin(theta));
					becvfRot[6+2] = (Math.cos(theta));
					
					for ( var j = 0; j < WIDTH; j++ ) {
					
						psi = 2.0 * Math.PI * j / WIDTH;
						
						var becvf1 = new Float32Array([0.0, (effectController.radius * Math.cos(psi)), (-effectController.radius * Math.sin(psi))]);
						
						positions[ p++ ] = becvf1[0]*becvfRot[0+0] + becvf1[1]*becvfRot[0+1] + becvf1[2]*becvfRot[0+2];
						positions[ p++ ] = becvf1[0]*becvfRot[3+0] + becvf1[1]*becvfRot[3+1] + becvf1[2]*becvfRot[3+2]; 
						positions[ p++ ] = becvf1[0]*becvfRot[6+0] + becvf1[1]*becvfRot[6+1] + becvf1[2]*becvfRot[6+2];
					}
				}

				p = 0;
				// Setup the UV array, which will contain a lookup-table of 0.0-1.0 for (i,j) based on the index:
				for ( var j = 0; j < WIDTH; j++ ) {

					for ( var i = 0; i < WIDTH; i++ ) {

						uvs[ p++ ] = i / ( WIDTH - 1 );
						uvs[ p++ ] = j / ( WIDTH - 1 );
					}
				}

				geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

				becvfUniforms = {
					//texturePosition: { value: null },
					//textureVelocity: { value: null },
					cameraConstant: { value: getCameraConstant( camera ) },
					uTime: {value: 0.0},
                    waveSpeed: { value: 0.25 },
					wavesPerRing: { value: 2.0 },
					showBECVF: { value: true },
					animateBECVF: { value: true },
					redBECVF: { value: 0.0 },
					greenBECVF: { value: 1.0 },
					blueBECVF: { value: 0.0 },
                    alphaBECVF: { value: 1.0 }
				};

				// ShaderMaterial
				var material = new THREE.ShaderMaterial( {
					uniforms:       becvfUniforms,
					vertexShader:   document.getElementById( 'becvfVertexShader' ).textContent,
					fragmentShader: document.getElementById( 'particleFragmentShader' ).textContent
				} );
				material.extensions.drawBuffers = true;

                becvfPoints = new THREE.Points( geometry, material );
                becvfPoints.matrixAutoUpdate = false;
				becvfPoints.updateMatrix();
                scene.add( becvfPoints );

                becvfLines = new THREE.LineLoop( geometry, material );
                becvfLines.matrixAutoUpdate = false;
                becvfLines.updateMatrix();
                scene.add( becvfLines );
			}

            // Geometry based on GUTCP Equation 1.95:
			function initOCVF() {

				geometry = new THREE.BufferGeometry();

				// Storage for all the locations for the BECVF:
				var positions = new Float32Array( VERTICES * 3 );
				var uvs = new Float32Array( VERTICES * 2 );
				var p = 0;
				var theta = 0.0;
				var psi = 0.0;

				// Populate the BECVF positions:
				for ( var i = 0; i < WIDTH; i++ ) {
				
					theta = 2.0 * Math.PI * i / WIDTH;
					// Setup the 3x3 rotation matrix from GUTCP Eq(1.84)
					var becvfRot = new Float32Array(9);
					becvfRot[0+0] = ( 0.25 * (1.0 + 3.0*Math.cos(theta)));
					becvfRot[0+1] = ( 0.25 * (-1.0 + Math.cos(theta) + 2.0 * 1.414 * Math.sin(theta)));
					becvfRot[0+2] = ( 0.25 * (-1.414 + 1.414 * Math.cos(theta) - 2.0 * Math.sin(theta)));
					becvfRot[3+0] = ( 0.25 * (-1.0 + Math.cos(theta) - 2.0 * 1.414 * Math.sin(theta)));
					becvfRot[3+1] = ( 0.25 * (1.0 + 3.0*Math.cos(theta))); 
					becvfRot[3+2] = ( 0.25 * (1.414 - 1.414 * Math.cos(theta) - 2.0 * Math.sin(theta)));
					becvfRot[6+0] = ( 0.5 * (((-1 + Math.cos(theta))/1.414) + Math.sin(theta)));
					becvfRot[6+1] = ( 0.25 * (1.414 - 1.414 * Math.cos(theta) + 2.0 * Math.sin(theta)));
					becvfRot[6+2] = (Math.cos(theta*0.5) * Math.cos(theta*0.5));
					
					for ( var j = 0; j < WIDTH; j++ ) {
					
						psi = 2.0 * Math.PI * j / WIDTH;
						var becvf = new Float32Array([(0.707*effectController.radius * Math.cos(psi)), 
													  (0.707*effectController.radius * Math.cos(psi)), 
													  (-effectController.radius * Math.sin(psi))]);

						positions[ p++ ] = becvf[0]*becvfRot[0+0] + becvf[1]*becvfRot[0+1] + becvf[2]*becvfRot[0+2];
						positions[ p++ ] = becvf[0]*becvfRot[3+0] + becvf[1]*becvfRot[3+1] + becvf[2]*becvfRot[3+2]; 
						positions[ p++ ] = becvf[0]*becvfRot[6+0] + becvf[1]*becvfRot[6+1] + becvf[2]*becvfRot[6+2];
					}
				}

				p=0;
				// Setup the UV array, which will contain a lookup-table of 0.0-1.0 for (i,j) based on the index:
				for ( var j = 0; j < WIDTH; j++ ) {

					for ( var i = 0; i < WIDTH; i++ ) {

						uvs[ p++ ] = i / ( WIDTH - 1 );
						uvs[ p++ ] = j / ( WIDTH - 1 );
					}
				}

				geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

				ocvfUniforms = {
					//texturePosition: { value: null },
					//textureVelocity: { value: null },
					cameraConstant: { value: getCameraConstant( camera ) },
					uTime: {value: 0.0},
                    waveSpeed: { value: 0.25 },
					wavesPerRing: { value: 2.0 },
					showOCVF: { value: true },
					animateOCVF: { value: true },
					redOCVF: { value: 0.0 },
					greenOCVF: { value: 1.0 },
					blueOCVF: { value: 0.0 },
                    alphaOCVF: { value: 1.0 }
				};

				// ShaderMaterial
				var material = new THREE.ShaderMaterial( {
					uniforms:       ocvfUniforms,
					vertexShader:   document.getElementById( 'ocvfVertexShader' ).textContent,
					fragmentShader: document.getElementById( 'particleFragmentShader' ).textContent
				} );
				material.extensions.drawBuffers = true;

                ocvfLines = new THREE.LineLoop( geometry, material );
                ocvfLines.matrixAutoUpdate = false;
                ocvfLines.updateMatrix();
                scene.add( ocvfLines );

                ocvfPoints = new THREE.Points( geometry, material );
				ocvfPoints.matrixAutoUpdate = false;
				ocvfPoints.updateMatrix();
				scene.add( ocvfPoints );
			}

            // Geometry based on GUTCP Equation 1.103:
            function initY_1_103() {

				geometry = new THREE.BufferGeometry();

                // Storage for all the locations for the BECVF:
                var M = WIDTH / 5;
                var N = WIDTH / 5;
                var positions = new Float32Array( (M * N * WIDTH) * 3 );
                var uvs = new Float32Array( (M * N * WIDTH) * 2 );
                var p = 0;
                var psi = 0.0;

                for (var m = 1; m <= M; m++) {
                    var m2piONm = 2.0 * Math.PI * m / M;
                    var m_matrix = new Float32Array(9);

                    m_matrix[0+0] = (0.25 * (1.0 + 3.0 * Math.cos(m2piONm)));
                    m_matrix[0+1] = (0.25 * (-1.0 + Math.cos(m2piONm) + 2.828 * Math.sin(m2piONm)));
                    m_matrix[0+2] = (0.25 * (-1.414 + 1.414 * Math.cos(m2piONm) - 2.0 * Math.sin(m2piONm)));
                    m_matrix[3+0] = (0.25 * (-1.0 + Math.cos(m2piONm) - 2.828 * Math.sin(m2piONm)));
                    m_matrix[3+1] = (0.25 * (1.0 + 3.0 * Math.cos(m2piONm)));
                    m_matrix[3+2] = (0.25 * (1.414 - 1.414 * Math.cos(m2piONm) - 2.0 * Math.sin(m2piONm)));
                    m_matrix[6+0] = (0.5 * (0.707 * (-1.0 + Math.cos(m2piONm)) + Math.sin(m2piONm)));
                    m_matrix[6+1] = (0.25 * (1.414 - 1.414 * Math.cos(m2piONm) + 2.0 * Math.sin(m2piONm)));
                    m_matrix[6+2] = (Math.cos(0.5 * m2piONm) * Math.cos(0.5 * m2piONm));

                    for (var n = 1; n <= N; n++) {
                        var n2piONn = 2.0 * Math.PI * n / N;
                        var n_matrix = new Float32Array(9);

                        n_matrix[0+0] = (0.5 + 0.5 * Math.cos(n2piONn));
                        n_matrix[0+1] = (-0.5 + 0.5 * Math.cos(n2piONn));
                        n_matrix[0+2] = (-Math.sin(n2piONn) * 0.707);
                        n_matrix[3+0] = (-0.5 + 0.5 * Math.cos(n2piONn));
                        n_matrix[3+1] = (0.5 + 0.5 * Math.cos(n2piONn));
                        n_matrix[3+2] = (-Math.sin(n2piONn) * 0.707);
                        n_matrix[6+0] = (Math.sin(n2piONn) * 0.707);
                        n_matrix[6+1] = (Math.sin(n2piONn) * 0.707);
                        n_matrix[6+2] = (Math.cos(n2piONn));

                        for (var i = 0; i < WIDTH; i++) {
                            psi = 2.0 * Math.PI * i / WIDTH;
                            var becvf = new Float32Array([(0.0),
                                                          (effectController.radius * Math.cos(psi)),
                                                          (-effectController.radius * Math.sin(psi))]);

                            var tx = n_matrix[0+0] * becvf[0] + n_matrix[0+1] * becvf[1] + n_matrix[0+2] * becvf[2];
                            var ty = n_matrix[3+0] * becvf[0] + n_matrix[3+1] * becvf[1] + n_matrix[3+2] * becvf[2];
                            var tz = n_matrix[6+0] * becvf[0] + n_matrix[6+1] * becvf[1] + n_matrix[6+2] * becvf[2];

                            positions[p++] = m_matrix[0+0] * tx + m_matrix[0+1] * ty + m_matrix[0+2] * tz;
                            positions[p++] = m_matrix[3+0] * tx + m_matrix[3+1] * ty + m_matrix[3+2] * tz;
                            positions[p++] = m_matrix[6+0] * tx + m_matrix[6+1] * ty + m_matrix[6+2] * tz;
                        }
                    }
                }

                p=0;
                // Setup the UV array, which will contain a lookup-table of 0.0-1.0 for (i,j) based on the index:
                // TODO - do we really need a uv with this???
                for ( var j = 1; j <= M; j++ ) {
                    for ( var i = 1; i <= N; i++ ) {
                        for(var k = 0; k < WIDTH; ++k) {
                            uvs[ p++ ] = k / ( WIDTH );
                            uvs[ p++ ] = k / ( WIDTH );
                        }
                    }
                }

                geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
                geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

                yUniforms_1_103 = {
                    cameraConstant: { value: getCameraConstant( camera ) },
                    uTime: {value: 0.0},
                    waveSpeed: { value: 0.25 },
                    wavesPerRing: { value: 2.0 },
                    animateY: { value: true },
                    redY: { value: 0.0 },
                    greenY: { value: 1.0 },
                    blueY: { value: 0.0 },
                    alphaY: { value: 1.0 }
                };
                
                // ShaderMaterial
                var material = new THREE.ShaderMaterial( {
                                                        uniforms:       yUniforms_1_103,
                                                        vertexShader:   document.getElementById( 'yVertexShader' ).textContent,
                                                        fragmentShader: document.getElementById( 'particleFragmentShader' ).textContent
                                                        } );
                                                        material.extensions.drawBuffers = true;
                                                        
                                                        yPoints_1_103 = new THREE.LineLoop( geometry, material );
                                                        yPoints_1_103.matrixAutoUpdate = false;
                                                        yPoints_1_103.updateMatrix();
                                                        scene.add( yPoints_1_103 );
                // Keep Y hidden initially:
                yPoints_1_103.visible = false;
            }

            function initY_1_109() {

				geometry = new THREE.BufferGeometry();

                // Storage for all the locations for the BECVF:
                var M = WIDTH / 5;
                var N = WIDTH / 5;
                var positions = new Float32Array( (M * N * WIDTH) * 3 );
                var uvs = new Float32Array( (M * N * WIDTH) * 2 );
                var p = 0;
                var psi = 0.0;

                for (var m = 1; m <= M; m++) {
                    var m2piONm = 2.0 * Math.PI * m / M;
                    var m_matrix = new Float32Array(9);

                    m_matrix[0+0] = (0.25 * (1.0 + 3.0 * Math.cos(m2piONm)));
                    m_matrix[0+1] = (0.25 * (-1.0 + Math.cos(m2piONm) + 2.828 * Math.sin(m2piONm)));
                    m_matrix[0+2] = (0.25 * (-1.414 + 1.414 * Math.cos(m2piONm) - 2.0 * Math.sin(m2piONm)));
                    m_matrix[3+0] = (0.25 * (-1.0 + Math.cos(m2piONm) - 2.828 * Math.sin(m2piONm)));
                    m_matrix[3+1] = (0.25 * (1.0 + 3.0 * Math.cos(m2piONm)));
                    m_matrix[3+2] = (0.25 * (1.414 - 1.414 * Math.cos(m2piONm) - 2.0 * Math.sin(m2piONm)));
                    m_matrix[6+0] = (0.5 * (0.707 * (-1.0 + Math.cos(m2piONm)) + Math.sin(m2piONm)));
                    m_matrix[6+1] = (0.25 * (1.414 - 1.414 * Math.cos(m2piONm) + 2.0 * Math.sin(m2piONm)));
                    m_matrix[6+2] = (Math.cos(0.5 * m2piONm) * Math.cos(0.5 * m2piONm));

                    for (var n = 1; n <= N; n++) {
                        var n2piONn = 2.0 * Math.PI * n / N;
                        var n_matrix = new Float32Array(9);

                        n_matrix[0+0] = (0.5 * Math.cos(n2piONn) - 0.5 * Math.sin(n2piONn));
                        n_matrix[0+1] = (0.707 * Math.cos(n2piONn) + 0.707 * Math.sin(n2piONn));
                        n_matrix[0+2] = (0.5 * Math.cos(n2piONn) - 0.5 * Math.sin(n2piONn));
                        n_matrix[3+0] = (-0.5 * Math.cos(n2piONn) - 0.5 * Math.sin(n2piONn));
                        n_matrix[3+1] = (0.707 * Math.cos(n2piONn) - 0.707 * Math.sin(n2piONn));
                        n_matrix[3+2] = (-0.5 * Math.cos(n2piONn) - 0.5 * Math.sin(n2piONn));
                        n_matrix[6+0] = (-0.707);
                        n_matrix[6+1] = (0.0);
                        n_matrix[6+2] = (0.707);

                        for (var i = 0; i < WIDTH; i++) {
                            psi = 2.0 * Math.PI * i / WIDTH;
                            var becvf = new Float32Array([(effectController.radius * Math.cos(psi)),
                                                          (effectController.radius * Math.sin(psi)),
                                                          (0.0)]);

                                                          var tx = n_matrix[0+0] * becvf[0] + n_matrix[0+1] * becvf[1] + n_matrix[0+2] * becvf[2];
                                                          var ty = n_matrix[3+0] * becvf[0] + n_matrix[3+1] * becvf[1] + n_matrix[3+2] * becvf[2];
                                                          var tz = n_matrix[6+0] * becvf[0] + n_matrix[6+1] * becvf[1] + n_matrix[6+2] * becvf[2];

                                                          positions[p++] = m_matrix[0+0] * tx + m_matrix[0+1] * ty + m_matrix[0+2] * tz;
                                                          positions[p++] = m_matrix[3+0] * tx + m_matrix[3+1] * ty + m_matrix[3+2] * tz;
                                                          positions[p++] = m_matrix[6+0] * tx + m_matrix[6+1] * ty + m_matrix[6+2] * tz;
                        }
                    }
                }

                p=0;
                // Setup the UV array, which will contain a lookup-table of 0.0-1.0 for (i,j) based on the index:
                // TODO - do we really need a uv with this???
                for ( var j = 1; j <= M; j++ ) {
                    for ( var i = 1; i <= N; i++ ) {
                        for(var k = 0; k < WIDTH; ++k) {
                            uvs[ p++ ] = k / ( WIDTH );
                            uvs[ p++ ] = k / ( WIDTH );
                        }
                    }
                }

                geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
                geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

                yUniforms_1_109 = {
                    cameraConstant: { value: getCameraConstant( camera ) },
                    uTime:      { value: 0.0 },
                    waveSpeed:  { value: 0.25 },
                    wavesPerRing: { value: 2.0 },
                    animateY:   { value: true },
                    redY:       { value: 0.0 },
                    greenY:     { value: 1.0 },
                    blueY:      { value: 0.0 },
                    alphaY:     { value: 1.0 }
                };

                // ShaderMaterial
                var material = new THREE.ShaderMaterial( {
                                                        uniforms:       yUniforms_1_109,
                                                        vertexShader:   document.getElementById( 'yVertexShader' ).textContent,
                                                        fragmentShader: document.getElementById( 'particleFragmentShader' ).textContent
                                                        } );
                                                        material.extensions.drawBuffers = true;

                                                        yPoints_1_109 = new THREE.LineLoop( geometry, material );
                                                        yPoints_1_109.matrixAutoUpdate = false;
                                                        yPoints_1_109.updateMatrix();
                                                        scene.add( yPoints_1_109 );
                                                        // Keep Y hidden initially:
                                                        yPoints_1_109.visible = false;
            }

            function initGrid() {

                var GRIDPOINTS = 3;
                var SEPARATION = 250.0 / GRIDPOINTS; // pixels
                geometry = new THREE.BufferGeometry();

                // Storage for all the locations for the BECVF:
                var positions = new Float32Array( 6 * ((GRIDPOINTS+1)**2) * 3 );
                var uvs = new Float32Array( 6 * ((GRIDPOINTS+1)**3) * 2 );
                var p = 0;
                var x = 0.0;
                var y = 0.0;
                var z = 0.0;

                // Populate the grid positions:
                for ( var i = 0; i <= GRIDPOINTS; i++ ) {

                    x = (i * SEPARATION) - (GRIDPOINTS * SEPARATION * 0.5);
                    for ( var j = 0; j <= GRIDPOINTS; j++ ) {

                        y = (j * SEPARATION) - (GRIDPOINTS * SEPARATION * 0.5);

                        positions[ p++ ] = x;
                        positions[ p++ ] = y;
                        positions[ p++ ] = -(GRIDPOINTS * SEPARATION * 0.5);

                        positions[ p++ ] = x;
                        positions[ p++ ] = y;
                        positions[ p++ ] = (GRIDPOINTS * SEPARATION * 0.5);
                    }
                }

                for ( var i = 0; i <= GRIDPOINTS; i++ ) {

                    x = (i * SEPARATION) - (GRIDPOINTS * SEPARATION * 0.5);
                    for ( var j = 0; j <= GRIDPOINTS; j++ ) {

                        y = (j * SEPARATION) - (GRIDPOINTS * SEPARATION * 0.5);

                        positions[ p++ ] = y;
                        positions[ p++ ] = -(GRIDPOINTS * SEPARATION * 0.5);
                        positions[ p++ ] = x;

                        positions[ p++ ] = y;
                        positions[ p++ ] = (GRIDPOINTS * SEPARATION * 0.5);
                        positions[ p++ ] = x;
                    }
                }

                for ( var i = 0; i <= GRIDPOINTS; i++ ) {

                    x = (i * SEPARATION) - (GRIDPOINTS * SEPARATION * 0.5);
                    for ( var j = 0; j <= GRIDPOINTS; j++ ) {

                        y = (j * SEPARATION) - (GRIDPOINTS * SEPARATION * 0.5);

                        positions[ p++ ] = -(GRIDPOINTS * SEPARATION * 0.5);
                        positions[ p++ ] = x;
                        positions[ p++ ] = y;

                        positions[ p++ ] = (GRIDPOINTS * SEPARATION * 0.5);
                        positions[ p++ ] = x;
                        positions[ p++ ] = y;
                    }
                }

                p = 0;
                // Setup the UV array, which will contain a lookup-table of 0.0-1.0 for (i,j) based on the index:
                // TODO - fix what we do about the grid uv:
                for ( var j = 0; j < GRIDPOINTS; j++ ) {

                    for ( var i = 0; i < GRIDPOINTS; i++ ) {

                        uvs[ p++ ] = i / ( WIDTH - 1 );
                        uvs[ p++ ] = j / ( WIDTH - 1 );
                    }
                }

                geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
                geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

                gridUniforms = {
                    cameraConstant: { value: getCameraConstant( camera ) },
                    brightGrid: { value: 0.4 },
                    alphaGrid: { value: 1.0 }
                };
                
                // ShaderMaterial
                var material = new THREE.ShaderMaterial( {
                                                        uniforms:       gridUniforms,
                                                        linewidth:      2,
                                                        vertexShader:   document.getElementById( 'gridVertexShader' ).textContent,
                                                        fragmentShader: document.getElementById( 'particleFragmentShader' ).textContent
                                                        } );
                                                        
                                                        material.extensions.drawBuffers = true;
                                                        
                                                        var VERTICES = new THREE.LineSegments( geometry, material );
                                                        VERTICES.matrixAutoUpdate = false;
                                                        VERTICES.updateMatrix();
                                                        
                                                        scene.add( VERTICES );
            }

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
				becvfUniforms.cameraConstant.value = getCameraConstant( camera );
			}

			function dynamicValuesChanger() {

                gridUniforms.brightGrid.value = effectController.brightGrid;
                gridUniforms.alphaGrid.value = effectController.alphaGrid;

                if(effectController.becvfGeometry == 'hide') {
                    becvfPoints.visible = false;
                    becvfLines.visible = false;
                } else if(effectController.becvfGeometry == 'points') {
                        becvfPoints.visible = true;
                        becvfLines.visible = false;
                } else {
                    becvfPoints.visible = false;
                    becvfLines.visible = true;
                }
                becvfUniforms.waveSpeed.value = effectController.waveSpeed;
				becvfUniforms.wavesPerRing.value = effectController.wavesPerRing;
				becvfUniforms.animateBECVF.value = effectController.animateBECVF;
				becvfUniforms.redBECVF.value   = effectController.redBECVF;
				becvfUniforms.greenBECVF.value = effectController.greenBECVF;
				becvfUniforms.blueBECVF.value  = effectController.blueBECVF;
                becvfUniforms.alphaBECVF.value  = effectController.alphaBECVF;

                if(effectController.ocvfGeometry == 'hide') {
                    ocvfPoints.visible = false;
                    ocvfLines.visible = false;
                } else if(effectController.ocvfGeometry == 'points') {
                        ocvfPoints.visible = true;
                        ocvfLines.visible = false;
                } else {
                    ocvfPoints.visible = false;
                    ocvfLines.visible = true;
                }
                ocvfUniforms.waveSpeed.value = effectController.waveSpeed;
				ocvfUniforms.wavesPerRing.value = effectController.wavesPerRing;
				ocvfUniforms.animateOCVF.value = effectController.animateOCVF;
				ocvfUniforms.redOCVF.value   = effectController.redOCVF;
				ocvfUniforms.greenOCVF.value = effectController.greenOCVF;
				ocvfUniforms.blueOCVF.value  = effectController.blueOCVF;
                ocvfUniforms.alphaOCVF.value  = effectController.alphaOCVF;

                yUniforms_1_103.waveSpeed.value = effectController.waveSpeed;
                yUniforms_1_103.wavesPerRing.value = effectController.wavesPerRing;
                yUniforms_1_103.animateY.value = effectController.animateY;
                yUniforms_1_103.redY.value   = effectController.redY;
                yUniforms_1_103.greenY.value = effectController.greenY;
                yUniforms_1_103.blueY.value  = effectController.blueY;
                yUniforms_1_103.alphaY.value  = effectController.alphaY;

                yUniforms_1_109.waveSpeed.value = effectController.waveSpeed;
                yUniforms_1_109.wavesPerRing.value = effectController.wavesPerRing;
                yUniforms_1_109.animateY.value = effectController.animateYortho;
                yUniforms_1_109.redY.value   = effectController.redYortho;
                yUniforms_1_109.greenY.value = effectController.greenYortho;
                yUniforms_1_109.blueY.value  = effectController.blueYortho;
                yUniforms_1_109.alphaY.value  = effectController.alphaYortho;
			}

			function initGUI() {

				var gui = new dat.GUI();

				var folder1 = gui.addFolder( 'Common parameters' );
                folder1.add( effectController, "waveSpeed", 0.05, 3.0, 0.05 ).onChange( dynamicValuesChanger );
				folder1.add( effectController, "wavesPerRing", 1.0, 10.0, 1.00 ).onChange( dynamicValuesChanger );
				folder1.add( effectController, "brightGrid", 0.0, 1.0, 0.05 ).onChange( dynamicValuesChanger );
				//folder1.add( effectController, "alphaGrid", 0.0, 1.0, 0.05 ).onChange( dynamicValuesChanger );

				var folder2 = gui.addFolder( 'BECVF - Basis Element CVF (Eq 1.84)' );
                folder2.add( effectController, "becvfGeometry", ['hide', 'points', 'lines'] ).onChange( dynamicValuesChanger );
				folder2.add( effectController, "animateBECVF" ).onChange( dynamicValuesChanger );
				folder2.add( effectController, "redBECVF", 0.0, 1.0, 0.05 ).onChange( dynamicValuesChanger );
				folder2.add( effectController, "greenBECVF", 0.0, 1.0, 0.05 ).onChange( dynamicValuesChanger );
				folder2.add( effectController, "blueBECVF", 0.0, 1.0, 0.05 ).onChange( dynamicValuesChanger );
                //folder2.add( effectController, "alphaBECVF", 0.0, 1.0, 0.05 ).onChange( dynamicValuesChanger );

				var folder3 = gui.addFolder( 'OCVF - Orbitsphere CVF (Eq 1.95)' );
                folder3.add( effectController, "ocvfGeometry", ['hide', 'points', 'lines'] ).onChange( dynamicValuesChanger );
				folder3.add( effectController, "animateOCVF" ).onChange( dynamicValuesChanger );
				folder3.add( effectController, "redOCVF", 0.0, 1.0, 0.05 ).onChange( dynamicValuesChanger );
				folder3.add( effectController, "greenOCVF", 0.0, 1.0, 0.05 ).onChange( dynamicValuesChanger );
				folder3.add( effectController, "blueOCVF", 0.0, 1.0, 0.05 ).onChange( dynamicValuesChanger );
                //folder3.add( effectController, "alphaOCVF", 0.0, 1.0, 0.05 ).onChange( dynamicValuesChanger );

                var folder4 = gui.addFolder( 'Y - Current Density Func (Eq 1.103)' );
                folder4.add( yPoints_1_103, "visible" ).onChange( dynamicValuesChanger );
                folder4.add( effectController, "animateY" ).onChange( dynamicValuesChanger );
                folder4.add( effectController, "redY", 0.0, 1.0, 0.05 ).onChange( dynamicValuesChanger );
                folder4.add( effectController, "greenY", 0.0, 1.0, 0.05 ).onChange( dynamicValuesChanger );
                folder4.add( effectController, "blueY", 0.0, 1.0, 0.05 ).onChange( dynamicValuesChanger );
                //folder4.add( effectController, "alphaY", 0.0, 1.0, 0.05 ).onChange( dynamicValuesChanger );

                var folder5 = gui.addFolder( 'Y - Current Density Func (Eq 1.109)' );
                folder5.add( yPoints_1_109, "visible" ).onChange( dynamicValuesChanger );
                folder5.add( effectController, "animateYortho" ).onChange( dynamicValuesChanger );
                folder5.add( effectController, "redYortho", 0.0, 1.0, 0.05 ).onChange( dynamicValuesChanger );
                folder5.add( effectController, "greenYortho", 0.0, 1.0, 0.05 ).onChange( dynamicValuesChanger );
                folder5.add( effectController, "blueYortho", 0.0, 1.0, 0.05 ).onChange( dynamicValuesChanger );
                //folder5.add( effectController, "alphaYortho", 0.0, 1.0, 0.05 ).onChange( dynamicValuesChanger );

				folder1.open();
				folder2.open();
				folder3.open();
                folder4.open();
                folder5.open();
			}

			function getCameraConstant( camera ) {
				return window.innerHeight / ( Math.tan( THREE.Math.DEG2RAD * 0.5 * camera.fov ) / camera.zoom );
			}

			function animate() {

				// Update the elapsed time to later provide to the shaders:
				var delta = clock.getDelta();
				tick += delta;
				if ( tick < 0 ) tick = 0;
				
				// Update the material uniforms with the time, to pass on the elapsed time:
				becvfUniforms.uTime.value = tick;
				ocvfUniforms.uTime.value = tick;
                yUniforms_1_103.uTime.value = tick;
                yUniforms_1_109.uTime.value = tick;

				// Tell WebGL to call the 'animate()' function for the next screen refresh:
				requestAnimationFrame( animate );
				
				// Render the scene, and update the stats:
				renderer.render( scene, camera );
				stats.update();
			}

		</script>
	</body>
</html>