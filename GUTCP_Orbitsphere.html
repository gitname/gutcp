<!DOCTYPE html>
<html lang="en">
	<head>
		<title>GUTCP Orbitsphere CVFS Demo</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				text-align:center;
				cursor: pointer;
			}

			a {
				color:#0078ff;
			}

			#info {
				color: #ffffff;
				position: absolute;
				top: 10px;
				width: 100%;
			}

			#warning {
				color: #ff0000;
			}

		</style>
	</head>
	<body>

        <div id="info">
            <a href="http://www.brilliantlightpower.com/book/" target="_blank" rel="noopener">GUTCP Ch 1.5 - Generation of the Orbitsphere CVFs</a>
            <br>Physics by : <a href="mailto:rmills@brilliantlightpower.com">Dr Randell L Mills</a> - Simulation by : <a href="mailto:vacamiguel@gmail.com">J Miguel Vaca</a> 
            <br> Select points per great circle: <span id="options"></span><br/>
        </div>

		<script src="https://threejs.org/build/three.js"></script>
		<script src="https://threejs.org/examples/js/Detector.js"></script>
		<script src="https://threejs.org/examples/js/libs/stats.min.js"></script>
		<script src="https://threejs.org/examples/js/libs/dat.gui.min.js"></script>
		<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>

        <!-- VERTICES vertex shader - Use this to update the position due to camera projection -->
		<script id="cvfVertexShader" type="x-shader/x-vertex">

			// For PI declaration:
			#include <common>

			uniform float cameraConstant;
			uniform float wavesPerRev;
            		uniform float waveSpeed;
			uniform float uTime;
			uniform bool  animate;
			uniform vec4  color;

			varying vec4 vColor;

			void main() {
			
				if(animate) {
                    float bright = mod(waveSpeed*uTime+uv.y, 1.0/wavesPerRev) * wavesPerRev;
					//float bright = (cos((2.0*3.1416*waveSpeed*uTime*wavesPerRev)+(2.0*3.1416*uv.y*wavesPerRev)) + 1.0) * 0.5;
                    vColor = vec4( (1.0-bright)*color[0], (1.0-bright)*color[1], (1.0-bright)*color[2], color[3] );
				} else {
                    vColor = color;
				}

				vec4 mvPosition = modelViewMatrix * vec4( position.xyz, 1.0 );
				
				gl_PointSize = 3.0;
				gl_Position = projectionMatrix * mvPosition;
			}

		</script>

        <!-- Grid vertex shader - Use this to update the position due to camera projection -->
        <script id="gridVertexShader" type="x-shader/x-vertex">

            // For PI declaration:
            #include <common>

            uniform float cameraConstant;
            uniform float gridBrightness;
            uniform float alphaGrid;

            varying vec4 vColor;

            void main() {

                vColor = vec4( gridBrightness, gridBrightness, gridBrightness, alphaGrid );

                vec4 mvPosition = modelViewMatrix * vec4( position.xyz, 1.0 );

                gl_PointSize = 2.0;
                gl_Position = projectionMatrix * mvPosition;
            }
        </script>

		<!-- VERTICES fragment shader -->
		<script id="particleFragmentShader" type="x-shader/x-fragment">

			varying vec4 vColor;

			void main() {
				gl_FragColor = vColor;
			}

		</script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var isIE = /Trident/i.test( navigator.userAgent );
			var isEdge = /Edge/i.test( navigator.userAgent );

			var hash = document.location.hash.substr( 1 );
            var WIDTH = 0;

            // Set 'WIDTH' to option hash if set, else set it to 60 (vertices per ring) and (rings per rotation)
            if ( hash ) {
                hash = parseInt( hash, 0 );
                WIDTH = hash;
            } else {
                WIDTH = 60;
            }

			var container, stats;
			var camera, scene, renderer, geometry, controls;
			var clock = new THREE.Clock();
			var tick = 0;
			
			var VERTICES = WIDTH * WIDTH;
			
			function change( n ) {
				location.hash = n;
				location.reload();
				return false;
			}

            var options = '';
            for ( var i = 1; i <= 6; i++ ) {
                var j = i * 60;
                if(WIDTH != j) {
                	options += '<a href="#" onclick="return change(' + j + ')">' + j + '</a> ';
                } else {
                	options += j + ' ';
                }
            }

            document.getElementById( 'options' ).innerHTML = options;

			if ( isEdge || isIE ) {
				document.getElementById( 'warning' ).innerText = 'particle counts greater than 16 may not render with ' + ( isEdge ? 'Edge' : 'IE11' );
			}

            var becvfPoints;
            var becvfLines;
			var becvfUniforms;

            var ocvfPoints;
            var ocvfLines;
			var ocvfUniforms;

            var yPoints_1_103;
            var yPoints_1_109;
            
            var blackSphere;

			var gridGeometry;
            var gridUniforms;

            var effectController;

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 5, 15000 );
				camera.position.y = 120;
				camera.position.z = 400;

				scene = new THREE.Scene();

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				controls = new THREE.OrbitControls( camera, renderer.domElement );

				effectController = {
					// Can be changed dynamically
                    radius: 100.0,
                    waveSpeed: 0.50,
					wavesPerRev: 2.0,

                    gridBrightness: 0.4,
                    alphaGrid:  1.0,
                    enableBlkSphere: false,

                    becvfGeometry: 'lines',
					showBECVF: true,
					animateBECVF: true,
					colorBECVF: [255, 0, 0, 1.0],

                    ocvfGeometry: 'lines',
					showOCVF: true,
					animateOCVF: true,
					colorOCVF: [0, 0, 255, 1.0],

                    yGeometry: 'hide',
                    animateY: true,
					colorY: [0, 255, 0, 1.0],

                    yyGeometry:  'hide',
                    animateYy: true,
					colorYy: [255, 0, 255, 1.0]
				};

				//initComputeRenderer();

				stats = new Stats();
				container.appendChild( stats.dom );

				window.addEventListener( 'resize', onWindowResize, false );

                initGrid();
				initBECVF();
				initOCVF();
                initY_1_103();
                initY_1_109();
                init_CurrentDensity();

                initGUI();

				dynamicValuesChanger();
			}
			
            // Geometry based on GUTCP Equation 1.84:
			function initBECVF() {

				geometry = new THREE.BufferGeometry();

				// Storage for all the locations for the BECVF:
				var positions = new Float32Array( VERTICES * 3 );
				var uvs = new Float32Array( VERTICES * 2 );
				var p = 0;
				var theta = 0.0;
				var psi = 0.0;


				// Populate the BECVF positions:
				for ( var i = 0; i < WIDTH; i++ ) {
				
					theta = 2.0 * Math.PI * i / WIDTH;
					// Setup the 3x3 rotation matrix from GUTCP Eq(1.84)
					var becvfRot = new Float32Array(9);
					becvfRot[0+0] = ( 0.5 + 0.5*Math.cos(theta));
					becvfRot[0+1] = (-0.5 + 0.5*Math.cos(theta));
					becvfRot[0+2] = (-0.70711*Math.sin(theta));
					becvfRot[3+0] = (-0.5 + 0.5*Math.cos(theta));
					becvfRot[3+1] = ( 0.5 + 0.5*Math.cos(theta)); 
					becvfRot[3+2] = (-0.70711*Math.sin(theta));
					becvfRot[6+0] = ( 0.70711*Math.sin(theta));
					becvfRot[6+1] = ( 0.70711*Math.sin(theta));
					becvfRot[6+2] = (Math.cos(theta));
					
					for ( var j = 0; j < WIDTH; j++ ) {
					
						psi = 2.0 * Math.PI * j / WIDTH;
						
						var becvf1 = new Float32Array([0.0, (effectController.radius * Math.cos(psi)), (-effectController.radius * Math.sin(psi))]);
						
						positions[ p++ ] = becvf1[0]*becvfRot[0+0] + becvf1[1]*becvfRot[0+1] + becvf1[2]*becvfRot[0+2];
						positions[ p++ ] = becvf1[0]*becvfRot[3+0] + becvf1[1]*becvfRot[3+1] + becvf1[2]*becvfRot[3+2]; 
						positions[ p++ ] = becvf1[0]*becvfRot[6+0] + becvf1[1]*becvfRot[6+1] + becvf1[2]*becvfRot[6+2];
					}
				}

				p = 0;
				// Setup the UV array, which will contain a lookup-table of 0.0-1.0 for (i,j) based on the index:
				for ( var j = 0; j < WIDTH; j++ ) {

					for ( var i = 0; i < WIDTH; i++ ) {

						uvs[ p++ ] = i / ( WIDTH - 1 );
						uvs[ p++ ] = j / ( WIDTH - 1 );
					}
				}

				geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

				becvfUniforms = {
					//texturePosition: { value: null },
					//textureVelocity: { value: null },
					cameraConstant: { value: getCameraConstant( camera ) },
					uTime: {value: 0.0},
                    waveSpeed: { value: 0.25 },
					wavesPerRev: { value: 2.0 },
					animate: { value: true },
					color: { value: new THREE.Vector4([0.0, 0.0, 1.0, 1.0]) }
				};

				// ShaderMaterial
				var material = new THREE.ShaderMaterial( {
					uniforms:       becvfUniforms,
					vertexShader:   document.getElementById( 'cvfVertexShader' ).textContent,
					fragmentShader: document.getElementById( 'particleFragmentShader' ).textContent
				} );
				material.extensions.drawBuffers = true;

                becvfPoints = new THREE.Points( geometry, material );
                becvfPoints.matrixAutoUpdate = false;
				becvfPoints.updateMatrix();
                scene.add( becvfPoints );

                becvfLines = new THREE.LineLoop( geometry, material );
                becvfLines.matrixAutoUpdate = false;
                becvfLines.updateMatrix();
                scene.add( becvfLines );
			}

            // Geometry based on GUTCP Equation 1.95:
			function initOCVF() {

				geometry = new THREE.BufferGeometry();

				// Storage for all the locations for the BECVF:
				var positions = new Float32Array( VERTICES * 3 );
				var uvs = new Float32Array( VERTICES * 2 );
				var p = 0;
				var theta = 0.0;
				var psi = 0.0;

				// Populate the BECVF positions:
				for ( var i = 0; i < WIDTH; i++ ) {
				
					theta = 2.0 * Math.PI * i / WIDTH;
					// Setup the 3x3 rotation matrix from GUTCP Eq(1.84)
					var ocvfRot = new Float32Array(9);
					ocvfRot[0+0] = ( 0.25 * (1.0 + 3.0*Math.cos(theta)));
					ocvfRot[0+1] = ( 0.25 * (-1.0 + Math.cos(theta) + 2.0 * 1.414 * Math.sin(theta)));
					ocvfRot[0+2] = ( 0.25 * (-1.414 + 1.414 * Math.cos(theta) - 2.0 * Math.sin(theta)));
					ocvfRot[3+0] = ( 0.25 * (-1.0 + Math.cos(theta) - 2.0 * 1.414 * Math.sin(theta)));
					ocvfRot[3+1] = ( 0.25 * (1.0 + 3.0*Math.cos(theta))); 
					ocvfRot[3+2] = ( 0.25 * (1.414 - 1.414 * Math.cos(theta) - 2.0 * Math.sin(theta)));
					ocvfRot[6+0] = ( 0.5 * (((-1 + Math.cos(theta))/1.414) + Math.sin(theta)));
					ocvfRot[6+1] = ( 0.25 * (1.414 - 1.414 * Math.cos(theta) + 2.0 * Math.sin(theta)));
					ocvfRot[6+2] = (Math.cos(theta*0.5) * Math.cos(theta*0.5));
					
					for ( var j = 0; j < WIDTH; j++ ) {
					
						psi = 2.0 * Math.PI * j / WIDTH + 0.5 * Math.PI;  // Half-PI phase addition is to correct a kink artefact
						var ocvf = new Float32Array([(0.707*effectController.radius * Math.cos(psi)), 
													  (0.707*effectController.radius * Math.cos(psi)), 
													  (-effectController.radius * Math.sin(psi))]);

						positions[ p++ ] = ocvf[0]*ocvfRot[0+0] + ocvf[1]*ocvfRot[0+1] + ocvf[2]*ocvfRot[0+2];
						positions[ p++ ] = ocvf[0]*ocvfRot[3+0] + ocvf[1]*ocvfRot[3+1] + ocvf[2]*ocvfRot[3+2]; 
						positions[ p++ ] = ocvf[0]*ocvfRot[6+0] + ocvf[1]*ocvfRot[6+1] + ocvf[2]*ocvfRot[6+2];
					}
				}

				p=0;
				// Setup the UV array, which will contain a lookup-table of 0.0-1.0 for (i,j) based on the index:
				for ( var j = 0; j < WIDTH; j++ ) {

					for ( var i = 0; i < WIDTH; i++ ) {

						uvs[ p++ ] = i / ( WIDTH - 1 );
						uvs[ p++ ] = j / ( WIDTH - 1 );
					}
				}

				geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

				ocvfUniforms = {
					//texturePosition: { value: null },
					//textureVelocity: { value: null },
					cameraConstant: { value: getCameraConstant( camera ) },
					uTime: {value: 0.0},
                    waveSpeed: { value: 0.25 },
					wavesPerRev: { value: 2.0 },
					animate: { value: true },
					color: {value: new THREE.Vector4([1.0, 0.0, 0.0, 1.0])}
				};

				// ShaderMaterial
				var material = new THREE.ShaderMaterial( {
					uniforms:       ocvfUniforms,
					vertexShader:   document.getElementById( 'cvfVertexShader' ).textContent,
					fragmentShader: document.getElementById( 'particleFragmentShader' ).textContent
				} );
				material.extensions.drawBuffers = true;

                ocvfLines = new THREE.LineLoop( geometry, material );
                ocvfLines.matrixAutoUpdate = false;
                ocvfLines.updateMatrix();
                scene.add( ocvfLines );

                ocvfPoints = new THREE.Points( geometry, material );
				ocvfPoints.matrixAutoUpdate = false;
				ocvfPoints.updateMatrix();
				scene.add( ocvfPoints );
			}

            // Geometry based on GUTCP Equation 1.103:
            function initY_1_103() {

				geometry = new THREE.BufferGeometry();

                // Storage for all the locations for the BECVF:
                var M = WIDTH / 5;
                var N = WIDTH / 5;
                var positions = new Float32Array( (M * N * WIDTH) * 3 );
                var uvs = new Float32Array( (M * N * WIDTH) * 2 );
                var p = 0;
                var psi = 0.0;

                for (var m = 1; m <= M; m++) {
                    var m2piONm = 2.0 * Math.PI * m / M;
                    var m_matrix = new Float32Array(9);

                    m_matrix[0+0] = (0.25 * (1.0 + 3.0 * Math.cos(m2piONm)));
                    m_matrix[0+1] = (0.25 * (-1.0 + Math.cos(m2piONm) + 2.828 * Math.sin(m2piONm)));
                    m_matrix[0+2] = (0.25 * (-1.414 + 1.414 * Math.cos(m2piONm) - 2.0 * Math.sin(m2piONm)));
                    m_matrix[3+0] = (0.25 * (-1.0 + Math.cos(m2piONm) - 2.828 * Math.sin(m2piONm)));
                    m_matrix[3+1] = (0.25 * (1.0 + 3.0 * Math.cos(m2piONm)));
                    m_matrix[3+2] = (0.25 * (1.414 - 1.414 * Math.cos(m2piONm) - 2.0 * Math.sin(m2piONm)));
                    m_matrix[6+0] = (0.5 * (0.707 * (-1.0 + Math.cos(m2piONm)) + Math.sin(m2piONm)));
                    m_matrix[6+1] = (0.25 * (1.414 - 1.414 * Math.cos(m2piONm) + 2.0 * Math.sin(m2piONm)));
                    m_matrix[6+2] = (Math.cos(0.5 * m2piONm) * Math.cos(0.5 * m2piONm));

                    for (var n = 1; n <= N; n++) {
                        var n2piONn = 2.0 * Math.PI * n / N;
                        var n_matrix = new Float32Array(9);

                        n_matrix[0+0] = (0.5 + 0.5 * Math.cos(n2piONn));
                        n_matrix[0+1] = (-0.5 + 0.5 * Math.cos(n2piONn));
                        n_matrix[0+2] = (-Math.sin(n2piONn) * 0.707);
                        n_matrix[3+0] = (-0.5 + 0.5 * Math.cos(n2piONn));
                        n_matrix[3+1] = (0.5 + 0.5 * Math.cos(n2piONn));
                        n_matrix[3+2] = (-Math.sin(n2piONn) * 0.707);
                        n_matrix[6+0] = (Math.sin(n2piONn) * 0.707);
                        n_matrix[6+1] = (Math.sin(n2piONn) * 0.707);
                        n_matrix[6+2] = (Math.cos(n2piONn));

                        for (var i = 0; i < WIDTH; i++) {
                            psi = 2.0 * Math.PI * i / WIDTH;
                            var becvf = new Float32Array([(0.0),
                                                          (effectController.radius * Math.cos(psi)),
                                                          (-effectController.radius * Math.sin(psi))]);

                            var tx = n_matrix[0+0] * becvf[0] + n_matrix[0+1] * becvf[1] + n_matrix[0+2] * becvf[2];
                            var ty = n_matrix[3+0] * becvf[0] + n_matrix[3+1] * becvf[1] + n_matrix[3+2] * becvf[2];
                            var tz = n_matrix[6+0] * becvf[0] + n_matrix[6+1] * becvf[1] + n_matrix[6+2] * becvf[2];

                            positions[p++] = m_matrix[0+0] * tx + m_matrix[0+1] * ty + m_matrix[0+2] * tz;
                            positions[p++] = m_matrix[3+0] * tx + m_matrix[3+1] * ty + m_matrix[3+2] * tz;
                            positions[p++] = m_matrix[6+0] * tx + m_matrix[6+1] * ty + m_matrix[6+2] * tz;
                        }
                    }
                }

                p=0;
                // Setup the UV array, which will contain a lookup-table of 0.0-1.0 for (i,j) based on the index:
                // TODO - do we really need a uv with this???
                for ( var j = 1; j <= M; j++ ) {
                    for ( var i = 1; i <= N; i++ ) {
                        for(var k = 0; k < WIDTH; ++k) {
                            uvs[ p++ ] = k / ( WIDTH );
                            uvs[ p++ ] = k / ( WIDTH );
                        }
                    }
                }

                geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
                geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

                yUniforms_1_103 = {
                    cameraConstant: { value: getCameraConstant( camera ) },
                    uTime: {value: 0.0},
                    waveSpeed: { value: 0.25 },
                    wavesPerRev: { value: 2.0 },
                    animate: { value: true },
					color: {value: new THREE.Vector4([0.0, 1.0, 0.0, 1.0])}
                };
                
                // ShaderMaterial
                var material = new THREE.ShaderMaterial( {
                                                        uniforms:       yUniforms_1_103,
                                                        vertexShader:   document.getElementById( 'cvfVertexShader' ).textContent,
                                                        fragmentShader: document.getElementById( 'particleFragmentShader' ).textContent
                                                        } );
                                                        material.extensions.drawBuffers = true;
                                                        
				yPoints_1_103 = new THREE.Points( geometry, material );
				yPoints_1_103.matrixAutoUpdate = false;
				yPoints_1_103.updateMatrix();
				scene.add( yPoints_1_103 );
                // Keep Y hidden initially:
                yPoints_1_103.visible = false;
                
				yLines_1_103 = new THREE.LineLoop( geometry, material );
				yLines_1_103.matrixAutoUpdate = false;
				yLines_1_103.updateMatrix();
				scene.add( yLines_1_103 );
                // Keep Y hidden initially:
                yLines_1_103.visible = false;
            }

            // Geometry based on GUTCP Equation 1.109:
            function initY_1_109() {

				geometry = new THREE.BufferGeometry();

                // Storage for all the locations for the BECVF:
                var M = WIDTH / 5;
                var N = WIDTH / 5;
                var positions = new Float32Array( (M * N * WIDTH) * 3 );
                var uvs = new Float32Array( (M * N * WIDTH) * 2 );
                var p = 0;
                var psi = 0.0;

                for (var m = 1; m <= M; m++) {
                    var m2piONm = 2.0 * Math.PI * m / M;
                    var m_matrix = new Float32Array(9);

                    m_matrix[0+0] = (0.25 * (1.0 + 3.0 * Math.cos(m2piONm)));
                    m_matrix[0+1] = (0.25 * (-1.0 + Math.cos(m2piONm) + 2.828 * Math.sin(m2piONm)));
                    m_matrix[0+2] = (0.25 * (-1.414 + 1.414 * Math.cos(m2piONm) - 2.0 * Math.sin(m2piONm)));
                    m_matrix[3+0] = (0.25 * (-1.0 + Math.cos(m2piONm) - 2.828 * Math.sin(m2piONm)));
                    m_matrix[3+1] = (0.25 * (1.0 + 3.0 * Math.cos(m2piONm)));
                    m_matrix[3+2] = (0.25 * (1.414 - 1.414 * Math.cos(m2piONm) - 2.0 * Math.sin(m2piONm)));
                    m_matrix[6+0] = (0.5 * (0.707 * (-1.0 + Math.cos(m2piONm)) + Math.sin(m2piONm)));
                    m_matrix[6+1] = (0.25 * (1.414 - 1.414 * Math.cos(m2piONm) + 2.0 * Math.sin(m2piONm)));
                    m_matrix[6+2] = (Math.cos(0.5 * m2piONm) * Math.cos(0.5 * m2piONm));

                    for (var n = 1; n <= N; n++) {
                        var n2piONn = 2.0 * Math.PI * n / N;
                        var n_matrix = new Float32Array(9);

                        n_matrix[0+0] = (0.5 * Math.cos(n2piONn) - 0.5 * Math.sin(n2piONn));
                        n_matrix[0+1] = (0.707 * Math.cos(n2piONn) + 0.707 * Math.sin(n2piONn));
                        n_matrix[0+2] = (0.5 * Math.cos(n2piONn) - 0.5 * Math.sin(n2piONn));
                        n_matrix[3+0] = (-0.5 * Math.cos(n2piONn) - 0.5 * Math.sin(n2piONn));
                        n_matrix[3+1] = (0.707 * Math.cos(n2piONn) - 0.707 * Math.sin(n2piONn));
                        n_matrix[3+2] = (-0.5 * Math.cos(n2piONn) - 0.5 * Math.sin(n2piONn));
                        n_matrix[6+0] = (-0.707);
                        n_matrix[6+1] = (0.0);
                        n_matrix[6+2] = (0.707);

                        for (var i = 0; i < WIDTH; i++) {
                            psi = 2.0 * Math.PI * i / WIDTH;
                            var becvf = new Float32Array([(effectController.radius * Math.cos(psi)),
                                                          (effectController.radius * Math.sin(psi)),
                                                          (0.0)]);

                                                          var tx = n_matrix[0+0] * becvf[0] + n_matrix[0+1] * becvf[1] + n_matrix[0+2] * becvf[2];
                                                          var ty = n_matrix[3+0] * becvf[0] + n_matrix[3+1] * becvf[1] + n_matrix[3+2] * becvf[2];
                                                          var tz = n_matrix[6+0] * becvf[0] + n_matrix[6+1] * becvf[1] + n_matrix[6+2] * becvf[2];

                                                          positions[p++] = m_matrix[0+0] * tx + m_matrix[0+1] * ty + m_matrix[0+2] * tz;
                                                          positions[p++] = m_matrix[3+0] * tx + m_matrix[3+1] * ty + m_matrix[3+2] * tz;
                                                          positions[p++] = m_matrix[6+0] * tx + m_matrix[6+1] * ty + m_matrix[6+2] * tz;
                        }
                    }
                }

                p=0;
                // Setup the UV array, which will contain a lookup-table of 0.0-1.0 for (i,j) based on the index:
                // TODO - do we really need a uv with this???
                for ( var j = 1; j <= M; j++ ) {
                    for ( var i = 1; i <= N; i++ ) {
                        for(var k = 0; k < WIDTH; ++k) {
                            uvs[ p++ ] = k / ( WIDTH );
                            uvs[ p++ ] = k / ( WIDTH );
                        }
                    }
                }

                geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
                geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

                yUniforms_1_109 = {
                    cameraConstant: { value: getCameraConstant( camera ) },
                    uTime:      { value: 0.0 },
                    waveSpeed:  { value: 0.25 },
                    wavesPerRev: { value: 2.0 },
                    animate:    { value: true },
					color: 		{ value: new THREE.Vector4([0.0, 1.0, 0.0, 1.0]) }
                };

                // ShaderMaterial
                var material = new THREE.ShaderMaterial( {
                                                        uniforms:       yUniforms_1_109,
                                                        vertexShader:   document.getElementById( 'cvfVertexShader' ).textContent,
                                                        fragmentShader: document.getElementById( 'particleFragmentShader' ).textContent
                                                        } );
                                                        material.extensions.drawBuffers = true;

				yPoints_1_109 = new THREE.Points( geometry, material );
				yPoints_1_109.matrixAutoUpdate = false;
				yPoints_1_109.updateMatrix();
				scene.add( yPoints_1_109 );
				// Keep Y hidden initially:
				yPoints_1_109.visible = false;

				yLines_1_109 = new THREE.LineLoop( geometry, material );
				yLines_1_109.matrixAutoUpdate = false;
				yLines_1_109.updateMatrix();
				scene.add( yLines_1_109 );
                // Keep Y hidden initially:
                yLines_1_109.visible = false;
            }

			function init_CurrentDensity() {
				// Create and insert a black sphere that can be used to obscure the back-half of the sphere.
				// Make its radius 99, which is less than the 100 radius of the rest of anim.
				geometry = new THREE.SphereBufferGeometry( 99, 32, 32 );
				var material = new THREE.MeshBasicMaterial( {color: 0x000000} );
				blackSphere = new THREE.Mesh( geometry, material );
				scene.add( blackSphere );            
			}
			

            function initGrid() {

                var GRIDPOINTS = 3;
                var SEPARATION = 250.0 / GRIDPOINTS; // pixels
                geometry = new THREE.BufferGeometry();

                // Storage for all the locations for the BECVF:
                var positions = new Float32Array( 6 * ((GRIDPOINTS+1)**2) * 3 );
                var uvs = new Float32Array( 6 * ((GRIDPOINTS+1)**3) * 2 );
                var p = 0;
                var x = 0.0;
                var y = 0.0;
                var z = 0.0;

                // Populate the grid positions:
                for ( var i = 0; i <= GRIDPOINTS; i++ ) {

                    x = (i * SEPARATION) - (GRIDPOINTS * SEPARATION * 0.5);
                    for ( var j = 0; j <= GRIDPOINTS; j++ ) {

                        y = (j * SEPARATION) - (GRIDPOINTS * SEPARATION * 0.5);

                        positions[ p++ ] = x;
                        positions[ p++ ] = y;
                        positions[ p++ ] = -(GRIDPOINTS * SEPARATION * 0.5);

                        positions[ p++ ] = x;
                        positions[ p++ ] = y;
                        positions[ p++ ] = (GRIDPOINTS * SEPARATION * 0.5);
                    }
                }

                for ( var i = 0; i <= GRIDPOINTS; i++ ) {

                    x = (i * SEPARATION) - (GRIDPOINTS * SEPARATION * 0.5);
                    for ( var j = 0; j <= GRIDPOINTS; j++ ) {

                        y = (j * SEPARATION) - (GRIDPOINTS * SEPARATION * 0.5);

                        positions[ p++ ] = y;
                        positions[ p++ ] = -(GRIDPOINTS * SEPARATION * 0.5);
                        positions[ p++ ] = x;

                        positions[ p++ ] = y;
                        positions[ p++ ] = (GRIDPOINTS * SEPARATION * 0.5);
                        positions[ p++ ] = x;
                    }
                }

                for ( var i = 0; i <= GRIDPOINTS; i++ ) {

                    x = (i * SEPARATION) - (GRIDPOINTS * SEPARATION * 0.5);
                    for ( var j = 0; j <= GRIDPOINTS; j++ ) {

                        y = (j * SEPARATION) - (GRIDPOINTS * SEPARATION * 0.5);

                        positions[ p++ ] = -(GRIDPOINTS * SEPARATION * 0.5);
                        positions[ p++ ] = x;
                        positions[ p++ ] = y;

                        positions[ p++ ] = (GRIDPOINTS * SEPARATION * 0.5);
                        positions[ p++ ] = x;
                        positions[ p++ ] = y;
                    }
                }

                p = 0;
                // Setup the UV array, which will contain a lookup-table of 0.0-1.0 for (i,j) based on the index:
                // TODO - fix what we do about the grid uv:
                for ( var j = 0; j < GRIDPOINTS; j++ ) {

                    for ( var i = 0; i < GRIDPOINTS; i++ ) {

                        uvs[ p++ ] = i / ( WIDTH - 1 );
                        uvs[ p++ ] = j / ( WIDTH - 1 );
                    }
                }

                geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
                geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

                gridUniforms = {
                    cameraConstant: { value: getCameraConstant( camera ) },
                    gridBrightness: { value: 0.4 },
                    alphaGrid: { value: 1.0 }
                };
                
                // ShaderMaterial
                var material = new THREE.ShaderMaterial( {
                                                        uniforms:       gridUniforms,
                                                        linewidth:      2,
                                                        vertexShader:   document.getElementById( 'gridVertexShader' ).textContent,
                                                        fragmentShader: document.getElementById( 'particleFragmentShader' ).textContent
                                                        } );
                                                        
                                                        material.extensions.drawBuffers = true;
                                                        
                                                        gridGeometry = new THREE.LineSegments( geometry, material );
                                                        gridGeometry.matrixAutoUpdate = false;
                                                        gridGeometry.updateMatrix();
                                                        
                                                        scene.add( gridGeometry );
            }

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
				becvfUniforms.cameraConstant.value = getCameraConstant( camera );
			}

			function dynamicValuesChanger() {

                gridUniforms.gridBrightness.value = effectController.gridBrightness;
                if(effectController.gridBrightness >= 0.05) {
                	gridGeometry.visible = true;
				} else {
                	gridGeometry.visible = false;
				}
                gridUniforms.alphaGrid.value = effectController.alphaGrid;
                blackSphere.visible = effectController.enableBlkSphere;

                if(effectController.becvfGeometry == 'hide') {
                    becvfPoints.visible = false;
                    becvfLines.visible = false;
                } else if(effectController.becvfGeometry == 'points') {
                        becvfPoints.visible = true;
                        becvfLines.visible = false;
                } else {
                    becvfPoints.visible = false;
                    becvfLines.visible = true;
                }
                becvfUniforms.waveSpeed.value = effectController.waveSpeed;
				becvfUniforms.wavesPerRev.value = effectController.wavesPerRev;
				becvfUniforms.animate.value = effectController.animateBECVF;
				becvfUniforms.color.value   = [effectController.colorBECVF[0]/255.0, 
												effectController.colorBECVF[1]/255.0,
												effectController.colorBECVF[2]/255.0, 
												effectController.colorBECVF[3]];

                if(effectController.ocvfGeometry == 'hide') {
                    ocvfPoints.visible = false;
                    ocvfLines.visible = false;
                } else if(effectController.ocvfGeometry == 'points') {
                        ocvfPoints.visible = true;
                        ocvfLines.visible = false;
                } else {
                    ocvfPoints.visible = false;
                    ocvfLines.visible = true;
                }
                ocvfUniforms.waveSpeed.value = effectController.waveSpeed;
				ocvfUniforms.wavesPerRev.value = effectController.wavesPerRev;
				ocvfUniforms.animate.value = effectController.animateOCVF;
				ocvfUniforms.color.value   = [effectController.colorOCVF[0]/255.0, 
											effectController.colorOCVF[1]/255.0,
											effectController.colorOCVF[2]/255.0, 
											effectController.colorOCVF[3]];

                yUniforms_1_103.waveSpeed.value = effectController.waveSpeed;
                yUniforms_1_103.wavesPerRev.value = effectController.wavesPerRev;
                yUniforms_1_103.animate.value = effectController.animateY;
				yUniforms_1_103.color.value   = [effectController.colorY[0]/255.0, 
												effectController.colorY[1]/255.0,
												effectController.colorY[2]/255.0, 
												effectController.colorY[3]];
                if(effectController.yGeometry == 'hide') {
                    yPoints_1_103.visible = false;
                    yLines_1_103.visible = false;
                } else if(effectController.yGeometry == 'points') {
                        yPoints_1_103.visible = true;
                        yLines_1_103.visible = false;
                } else {
                    yPoints_1_103.visible = false;
                    yLines_1_103.visible = true;
                }

                yUniforms_1_109.waveSpeed.value = effectController.waveSpeed;
                yUniforms_1_109.wavesPerRev.value = effectController.wavesPerRev;
                yUniforms_1_109.animate.value = effectController.animateYy;
				yUniforms_1_109.color.value   = [effectController.colorYy[0]/255.0, 
												effectController.colorYy[1]/255.0,
												effectController.colorYy[2]/255.0, 
												effectController.colorYy[3]];
                if(effectController.yyGeometry == 'hide') {
                    yPoints_1_109.visible = false;
                    yLines_1_109.visible = false;
                } else if(effectController.yyGeometry == 'points') {
                        yPoints_1_109.visible = true;
                        yLines_1_109.visible = false;
                } else {
                    yPoints_1_109.visible = false;
                    yLines_1_109.visible = true;
                }
			}

			function initGUI() {
				// Create the parameter control panel (on the right)
				var gui = new dat.GUI();

				// Add a folder to hold all the common parameters:
				var folder1 = gui.addFolder( 'Common parameters' );
                folder1.add( effectController, "waveSpeed", 0.05, 3.0, 0.05 ).onChange( dynamicValuesChanger );
				folder1.add( effectController, "wavesPerRev", 1.0, 10.0, 1.00 ).onChange( dynamicValuesChanger );
				folder1.add( effectController, "gridBrightness", 0.0, 1.0, 0.05 ).onChange( dynamicValuesChanger );
				// folder1.add( effectController, "alphaGrid", 0.0, 1.0, 0.05 ).onChange( dynamicValuesChanger );
                folder1.add( effectController, "enableBlkSphere" ).onChange( dynamicValuesChanger );

				// Add a folder for the BECVF parameters:
				var folder2 = gui.addFolder( 'BECVF - Basis Element CVF (Eq 1.84)' );
                folder2.add( effectController, "becvfGeometry", ['hide', 'points', 'lines'] ).onChange( dynamicValuesChanger );
				folder2.add( effectController, "animateBECVF" ).onChange( dynamicValuesChanger );
				folder2.addColor( effectController, "colorBECVF").onChange( dynamicValuesChanger );

				// Add a folder for the OCVF parameters:
				var folder3 = gui.addFolder( 'OCVF - Orbitsphere CVF (Eq 1.95)' );
                folder3.add( effectController, "ocvfGeometry", ['hide', 'points', 'lines'] ).onChange( dynamicValuesChanger );
				folder3.add( effectController, "animateOCVF" ).onChange( dynamicValuesChanger );
				folder3.addColor( effectController, "colorOCVF").onChange( dynamicValuesChanger );

				// Add a folder for the Y parameters:
                var folder4 = gui.addFolder( 'Y - Current Pattern Func (Eq 1.103)' );
                folder4.add( effectController, "yGeometry", ['hide', 'points', 'lines'] ).onChange( dynamicValuesChanger );
                folder4.add( effectController, "animateY" ).onChange( dynamicValuesChanger );
				folder4.addColor( effectController, "colorY").onChange( dynamicValuesChanger );

				// Add a folder for the Yy parameters:
                var folder5 = gui.addFolder( 'Y - Current Pattern Func (Eq 1.109)' );
                folder5.add( effectController, "yyGeometry", ['hide', 'points', 'lines'] ).onChange( dynamicValuesChanger );
                folder5.add( effectController, "animateYy" ).onChange( dynamicValuesChanger );
				folder5.addColor( effectController, "colorYy").onChange( dynamicValuesChanger );

				folder1.open();
				folder2.open();
				folder3.open();
                folder4.open();
                folder5.open();
			}

			function getCameraConstant( camera ) {
				return window.innerHeight / ( Math.tan( THREE.Math.DEG2RAD * 0.5 * camera.fov ) / camera.zoom );
			}

			function animate() {

				// Update the elapsed time to later provide to the shaders:
				var delta = clock.getDelta();
				tick += delta;
				if ( tick < 0 ) tick = 0;
				
				// Update the material uniforms with the time, to pass on the elapsed time:
				becvfUniforms.uTime.value = tick;
				ocvfUniforms.uTime.value = tick;
                yUniforms_1_103.uTime.value = tick;
                yUniforms_1_109.uTime.value = tick;

				// Tell WebGL to call the 'animate()' function for the next screen refresh:
				requestAnimationFrame( animate );
				
				// Render the scene, and update the stats:
				renderer.render( scene, camera );
				stats.update();
			}

		</script>
	</body>
</html>
